<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Table</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        table {
            width: 85%;
            margin: 2rem auto;
            border-collapse: collapse;
        }
        td {
            padding: 1rem;
            /* border: 1px solid #ccc; */
            position: relative;
        }
        .controls {
            display: none;
        }
        tr:hover .controls {
            display: inline;
            cursor: pointer;
        }
        .dropdown {
            margin: 0 2px;
        }
        
        /* Number input width fix */
        input[type="number"] {
            width: 80px;
        }
        
        /* Initially hide weight fields */
        .weight-label {
            display: none;
        }
        
        /* Add spacing between form elements */
        .file-row-controls label {
            margin-right: 0.5rem;
        }
        
        /* Remove Pico CSS background and color overrides */
        article {
            background: none !important;
        }
        
        article > footer,
        article > header {
            background-color: transparent !important;
        }
        
        body,
        main {
            background: transparent !important;
        }
        
        /* File row highlight animation */
        .file-row-highlight {
            background-color: #ffff00;
            animation: fadeOutHighlight 3s ease-out forwards;
        }
        
        @keyframes fadeOutHighlight {
            0% { background-color: #ffff00; }
            33% { background-color: #ffff00; }
            100% { background-color: transparent; }
        }
       
    </style>
</head>
<body>
    <table id="mainTable">
        <tbody>
            <tr id="noFilesRow">
                <td style="color: #888;">No files yet.</td>
            </tr>
            <!-- Filename rows will be inserted here -->
            <tr id="uploadRow">
                <td>
                    <button type="button" style="color: white" id="uploadButton">Upload</button>
                    <button type="button" style="color: white; margin-left: 1rem;" id="generateButton" onclick="showGenerateModal()">Generate</button>
                    <input type="file" id="fileInput" style="display:none;" multiple onchange="handleFiles(event)">
                </td>
            </tr>
            <tr id="repeatRow" style="display: none;">
                <td>
                    repeat <input type="number" min="1" value="10" style="width:3em; margin-left: 0.5rem; margin-right: 0.5rem;" id="repeatCount" oninput="updateTimesText()"> <span id="timesText">times</span>
                    <span style="margin-left: 1rem;">
                        <label><input type="radio" name="repeatMode" value="individual" checked onchange="updateWeightVisibility()"> each juror-case combination</label>
                        <label style="margin-left: 0.5rem;"><input type="radio" name="repeatMode" value="overall" onchange="updateWeightVisibility()"> overall</label>
                    </span>
                </td>
            </tr>
            <tr id="evaluateRow" style="display: none;">
                <td>
                    evaluate 
                    <label><input type="checkbox" id="cb_participation"> participation</label>
                    <label><input type="checkbox" id="cb_quality"> quality</label>
                    <label><input type="checkbox" id="cb_arguments"> arguments</label>
                </td>
            </tr>
            <tr id="runRow" style="display: none;">
                <td style="display: flex; justify-content: space-between; align-items: center;">
                    <button id="runButton" onclick="runProcess()" style="/* padding: 0.5em 1em; */ background: #007bff; color: white; /* border: none; */ /* border-radius: 4px; */ cursor: pointer;">Run Process</button>
                    <button type="button" style="color: white; display: none;" id="copyOutputButton" onclick="copyOutputToClipboard()">Copy output to clipboard</button>
                </td>
            </tr>
        </tbody>
    </table>

    <!-- Generate Jurors Modal -->
    <dialog id="generateModal">
        <article>
            <header>
                <h3>Generate Jurors</h3>
                <!-- <button aria-label="Close" rel="prev" onclick="closeGenerateModal()"></button> -->
            </header>
            <main id="modalContent">
                <div id="inputSection">
                    <p>How many jurors would you like to generate?</p>
                    <input type="number" id="modalJurorCount" min="1" max="20" value="5">
                    <div style="margin-top: 1rem; padding: 0.5rem; background: transparent; border: 1px solid var(--pico-muted-border-color); border-radius: 4px; font-size: 0.9em;">
                        <strong>Note:</strong> The online generation tool is in beta testing. <br>
                        Some features such as customizable presented distribution are not available online. 
                    </div>
                </div>
                <div id="terminalSection" style="display: none;">
                    <div id="terminalOutput" style="
                        background: #000;
                        color: #fff;
                        font-family: monospace;
                        padding: 1rem;
                        height: 280px;
                        overflow-y: auto;
                        border-radius: 4px;
                        white-space: pre-wrap;
                        font-size: 14px;
                    "></div>
                    <div style="display: flex; margin-top: 0.5rem;">
                        <input type="text" id="terminalInput" placeholder="Type your response here..." style="
                            flex: 1;
                            background: #333;
                            color: #fff;
                            border: 1px solid #555;
                            padding: 0.5rem;
                            font-family: monospace;
                            border-radius: 4px;
                        ">
                        <button onclick="sendTerminalInput()" style="
                            margin-left: 0.5rem;
                            background: #ffffff;
                            color: #000;
                            border: none;
                            padding: 0.5rem 1rem;
                            border-radius: 4px;
                            cursor: pointer;
                        ">Send</button>
                    </div>
                    <div style="margin-top: 0.5rem; font-size: 0.8em; color: #666;">
                        Common responses: <kbd>A</kbd> (Accept), <kbd>n</kbd> (New suggestion), <kbd>e</kbd> (Enter custom), <kbd>y</kbd>/<kbd>N</kbd> (Yes/No)
                    </div>
                </div>
            </main>
            <footer id="modalFooter">
                <button role="button" class="secondary" onclick="closeGenerateModal()">Cancel</button>
                <button role="button" id="generateConfirmButton" onclick="confirmGenerateJurors()">Generate</button>
            </footer>
        </article>
    </dialog>

    <script>
        const state = {};
        let uploadedFiles = []; // Store file objects, not just filenames
        let lastGeneratedFilename = null; // Track the last generated file for highlighting

        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up file upload');
            const uploadButton = document.getElementById('uploadButton');
            const fileInput = document.getElementById('fileInput');
            
            if (uploadButton && fileInput) {
                uploadButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log('Upload button clicked');
                    fileInput.click();
                });
                
                fileInput.addEventListener('change', function(event) {
                    console.log('File input change event fired');
                    handleFiles(event);
                });
                
                // Also listen for input event as fallback
                fileInput.addEventListener('input', function(event) {
                    console.log('File input input event fired');
                    handleFiles(event);
                });
                
                console.log('Event listeners attached successfully');
            } else {
                console.error('Upload elements not found');
            }
        });

        function showButton(i) {
            const btn = document.getElementById(`btn_${i}`);
            if (btn) btn.style.display = 'inline';
        }

        function hideButton(i) {
            const btn = document.getElementById(`btn_${i}`);
            if (btn && !state[i]) btn.style.display = 'none';
        }

        function togglePlay(i) {
            const btn = document.getElementById(`btn_${i}`);
            state[i] = !state[i];
            if (btn) {
                btn.textContent = state[i] ? "⏸" : "▶";
                btn.style.display = 'inline';
            }
        }

        function updateRowVisibility() {
            const hasFiles = uploadedFiles.length > 0;
            const repeatRow = document.getElementById('repeatRow');
            const evaluateRow = document.getElementById('evaluateRow');
            const runRow = document.getElementById('runRow');
            
            if (repeatRow) repeatRow.style.display = hasFiles ? '' : 'none';
            if (evaluateRow) evaluateRow.style.display = hasFiles ? '' : 'none';
            if (runRow) runRow.style.display = hasFiles ? '' : 'none';
            
            // Update weight visibility when rows become visible
            if (hasFiles) {
                updateWeightVisibility();
            }
        }

        function updateWeightVisibility() {
            const repeatModeRadio = document.querySelector('input[name="repeatMode"]:checked');
            const showWeights = repeatModeRadio && repeatModeRadio.value === 'overall';
            
            // Show/hide all weight fields
            const weightLabels = document.querySelectorAll('.weight-label');
            weightLabels.forEach(label => {
                label.style.display = showWeights ? 'inline' : 'none';
            });
        }

        function updateTimesText() {
            const repeatCount = document.getElementById('repeatCount');
            const timesText = document.getElementById('timesText');
            
            if (repeatCount && timesText) {
                const count = parseInt(repeatCount.value) || 0;
                timesText.textContent = count === 1 ? 'time' : 'times';
            }
        }

        function copyOutputToClipboard() {
            const outputArea = document.getElementById('outputArea');
            if (outputArea) {
                const text = outputArea.textContent || outputArea.innerText || '';
                
                // Use the modern clipboard API if available
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        console.log('Output copied to clipboard');
                        // Temporarily change button text to show success
                        const button = document.getElementById('copyOutputButton');
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        setTimeout(() => {
                            button.textContent = originalText;
                        }, 2000);
                    }).catch(err => {
                        console.error('Failed to copy to clipboard:', err);
                        alert('Failed to copy to clipboard');
                    });
                } else {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    
                    try {
                        document.execCommand('copy');
                        console.log('Output copied to clipboard (fallback)');
                        // Temporarily change button text to show success
                        const button = document.getElementById('copyOutputButton');
                        const originalText = button.textContent;
                        button.textContent = 'Copied!';
                        setTimeout(() => {
                            button.textContent = originalText;
                        }, 2000);
                    } catch (err) {
                        console.error('Failed to copy to clipboard:', err);
                        alert('Failed to copy to clipboard');
                    } finally {
                        document.body.removeChild(textArea);
                    }
                }
            } else {
                alert('No output to copy');
            }
        }

        function showGenerateModal() {
            const modal = document.getElementById('generateModal');
            if (modal) {
                modal.showModal();
                // Focus on the input field
                const input = document.getElementById('modalJurorCount');
                if (input) {
                    input.focus();
                    input.select();
                }
            }
        }

        function closeGenerateModal() {
            const modal = document.getElementById('generateModal');
            if (modal) {
                modal.close();
                // Reset modal to initial state
                resetGenerateModal();
                // Highlight the generated file row if available
                highlightGeneratedFileRow();
            }
        }

        function resetGenerateModal() {
            const inputSection = document.getElementById('inputSection');
            const terminalSection = document.getElementById('terminalSection');
            const modalFooter = document.getElementById('modalFooter');
            const terminalOutput = document.getElementById('terminalOutput');
            const terminalInput = document.getElementById('terminalInput');
            const sendButton = terminalInput?.nextElementSibling;
            
            if (inputSection) inputSection.style.display = 'block';
            if (terminalSection) terminalSection.style.display = 'none';
            if (terminalOutput) terminalOutput.innerHTML = '';
            
            // Reset terminal input state
            if (terminalInput) {
                terminalInput.style.display = 'block';
                terminalInput.disabled = false;
                terminalInput.value = '';
            }
            if (sendButton) {
                sendButton.style.display = 'block';
            }
            
            // Reset footer buttons
            if (modalFooter) {
                modalFooter.innerHTML = `
                    <button role="button" class="secondary" onclick="closeGenerateModal()">Cancel</button>
                    <button role="button" id="generateConfirmButton" onclick="confirmGenerateJurors()">Generate</button>
                `;
            }
            
            // Disconnect socket if connected
            if (socket) {
                socket.disconnect();
                socket = null;
            }
        }

        function confirmGenerateJurors() {
            const jurorCount = document.getElementById('modalJurorCount').value;
            
            // Switch to terminal view
            const inputSection = document.getElementById('inputSection');
            const terminalSection = document.getElementById('terminalSection');
            const modalFooter = document.getElementById('modalFooter');
            
            if (inputSection) inputSection.style.display = 'none';
            if (terminalSection) {
                terminalSection.style.display = 'block';
                // Focus the terminal input field
                setTimeout(() => {
                    const terminalInput = document.getElementById('terminalInput');
                    if (terminalInput) terminalInput.focus();
                }, 100);
            }
            
            // Update footer to show only close button
            if (modalFooter) {
                modalFooter.innerHTML = `
                    <button role="button" class="secondary" onclick="closeGenerateModal()">Cancel Generation</button>
                `;
            }
            
            // Start the generation process
            generateJurors(jurorCount);
        }

        // WebSocket connection for interactive terminal
        let socket = null;
        
        function processAnsiEscapes(text) {
            // Convert ANSI escape sequences to HTML spans with colors
            const ansiMap = {
                // Reset
                '0': 'color: #fff',
                // Text colors
                '30': 'color: #000', // black
                '31': 'color: #ff0000', // red
                '32': 'color: #00ff00', // green
                '33': 'color: #ffff00', // yellow
                '34': 'color: #0000ff', // blue
                '35': 'color: #ff00ff', // magenta
                '36': 'color: #00ffff', // cyan
                '37': 'color: #fff', // white
                // Bright colors
                '90': 'color: #808080', // bright black (gray)
                '91': 'color: #ff6666', // bright red
                '92': 'color: #66ff66', // bright green
                '93': 'color: #ffff66', // bright yellow
                '94': 'color: #6666ff', // bright blue
                '95': 'color: #ff66ff', // bright magenta
                '96': 'color: #66ffff', // bright cyan
                '97': 'color: #ffffff'  // bright white
            };
            
            // Replace ANSI escape sequences with HTML spans
            return text.replace(/\x1b\[([0-9;]*)m/g, function(match, codes) {
                if (!codes) return '</span>';
                
                const codeList = codes.split(';');
                const styles = codeList.map(code => ansiMap[code]).filter(style => style);
                
                if (styles.length > 0) {
                    return `<span style="${styles.join('; ')}">`;
                }
                return '';
            });
        }
        
        function initializeSocket() {
            if (!socket) {
                socket = io();
                
                socket.on('terminal_output', function(data) {
                    const terminalOutput = document.getElementById('terminalOutput');
                    if (terminalOutput) {
                        // Process ANSI escape sequences and append as HTML
                        const processedText = processAnsiEscapes(data.data);
                        terminalOutput.innerHTML += processedText;
                        terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    }
                });
                
                socket.on('generation_completed', function(data) {
                    const terminalOutput = document.getElementById('terminalOutput');
                    if (terminalOutput) {
                        terminalOutput.innerHTML += `\n\n<span style="color: white">═══════════════════════════════════════</span>\n`;
                        terminalOutput.innerHTML += `<span style="color: white">✓ GENERATION COMPLETED SUCCESSFULLY!</span>\n`;
                        terminalOutput.innerHTML += `<span style="color: #00ff00">Generated ${data.count} jurors\n`;
                        if (data.filename) {
                            terminalOutput.innerHTML += `Saved as: ${data.filename}\n`;
                        }
                        terminalOutput.innerHTML += `═══════════════════════════════════════</span>\n`;
                        terminalOutput.scrollTop = terminalOutput.scrollHeight;
                    }
                    
                    if (data.filename) {
                        lastGeneratedFilename = data.filename; // Store for highlighting later
                        addGeneratedFileToList(data.filename);
                    }
                    
                    // Hide terminal input since generation is complete
                    const terminalInput = document.getElementById('terminalInput');
                    const sendButton = terminalInput?.nextElementSibling;
                    if (terminalInput) {
                        terminalInput.style.display = 'none';
                        terminalInput.disabled = true;
                    }
                    if (sendButton) {
                        sendButton.style.display = 'none';
                    }
                    
                    // Update footer to show close button
                    const modalFooter = document.getElementById('modalFooter');
                    if (modalFooter) {
                        modalFooter.innerHTML = `
                            <button role="button" onclick="closeGenerateModal()">Close</button>
                        `;
                    }
                });
                
                socket.on('connect', function() {
                    console.log('Connected to server');
                    const terminalOutput = document.getElementById('terminalOutput');
                    if (terminalOutput && terminalOutput.innerHTML.includes('Connecting to interactive terminal')) {
                        terminalOutput.innerHTML += `<span style="color: #00ff00">Connected! Starting generation...</span>\n`;
                    }
                });
                
                socket.on('disconnect', function() {
                    console.log('Disconnected from server');
                    const terminalOutput = document.getElementById('terminalOutput');
                    if (terminalOutput) {
                        terminalOutput.innerHTML += `\n<span style="color: #ff6666">[CONNECTION LOST] Socket disconnected</span>\n`;
                    }
                });
                
                socket.on('connect_error', function(error) {
                    console.error('Connection error:', error);
                    const terminalOutput = document.getElementById('terminalOutput');
                    if (terminalOutput) {
                        terminalOutput.innerHTML += `\n<span style="color: #ff6666">[ERROR] Connection failed: ${error}</span>\n`;
                    }
                });
            }
        }

        function generateJurors(jurorCount) {
            const terminalOutput = document.getElementById('terminalOutput');
            if (!terminalOutput) return;
            
            // Initialize socket connection
            initializeSocket();
            
            terminalOutput.innerHTML = `<span style="color: #00ffff">Connecting to interactive terminal...</span>\n`;
            
            // Start the interactive generation process
            socket.emit('start_interactive_generation', {
                count: parseInt(jurorCount)
            });
        }
        
        function sendTerminalInput() {
            const terminalInput = document.getElementById('terminalInput');
            if (!terminalInput || !socket) return;
            
            const input = terminalInput.value;
            // Allow empty input (just pressing Enter is valid for some prompts)
            // Send input to server
            socket.emit('terminal_input', {
                input: input + '\n'  // Add newline
            });
            
            // Clear input field
            terminalInput.value = '';
        }
        
        // Allow sending input with Enter key
        document.addEventListener('DOMContentLoaded', function() {
            const terminalInput = document.getElementById('terminalInput');
            if (terminalInput) {
                terminalInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendTerminalInput();
                    }
                });
            }
        });

        function addGeneratedFileToList(filename) {
            // Create a file object representation for the generated file
            const fileObj = {
                file: null, // No actual File object for generated files
                name: filename,
                generated: true
            };
            
            // Remove "no files" row if present
            removeNoFilesRow();
            
            // Add file row FIRST (which will also add to uploadedFiles)
            addFileRow(fileObj);
            
            // Update row visibility
            updateRowVisibility();
            
            console.log(`Generated file ${filename} added to file list`);
        }

        // Close modal when clicking outside of it (backdrop click)
        document.getElementById('generateModal').addEventListener('click', function(event) {
            if (event.target === this) {
                closeGenerateModal();
            }
        });

        // Escape key handling is automatic with dialog element

        function handleFiles(event) {
            console.log('handleFiles called');
            const files = Array.from(event.target.files);
            console.log('Files selected:', files);
            
            if (files.length > 0) {
                console.log('Removing no files row');
                removeNoFilesRow();
                files.forEach(file => {
                    console.log('Adding file row for:', file.name);
                    // Store the actual file object with its name
                    const fileObj = {
                        file: file,
                        name: file.name
                    };
                    addFileRow(fileObj);
                });
                updateRowVisibility();
            } else {
                console.log('No files selected');
            }
            
            // Reset input so same file can be uploaded again if needed
            event.target.value = '';
        }

        function addFileRow(fileObj) {
            console.log('addFileRow called with:', fileObj.name);
            // Check if file already exists by name
            if (uploadedFiles.some(f => f.name === fileObj.name)) {
                console.log('File already exists, skipping:', fileObj.name);
                return;
            }
            
            uploadedFiles.push(fileObj);
            console.log('Current uploaded files:', uploadedFiles.map(f => f.name));
            
            const table = document.getElementById('mainTable').getElementsByTagName('tbody')[0];
            const uploadRow = document.getElementById('uploadRow');
            
            if (!table || !uploadRow) {
                console.error('Table or uploadRow not found');
                return;
            }
            
            // Check if file has .txt extension to determine default radio selection
            const isTxtFile = fileObj.name.toLowerCase().endsWith('.txt');
            const jurorChecked = isTxtFile ? '' : 'checked';
            const caseChecked = isTxtFile ? 'checked' : '';
            
            const row = document.createElement('tr');
            row.setAttribute('data-filename', fileObj.name);
            row.innerHTML = `
                <td>
                    <div class="file-row-container">
                        <span style="font-weight:bold;">${fileObj.name}</span>
                        <div class="file-row-controls">
                            <label class="weight-label">weight: <input type="number" id="weight_${fileObj.name}" min="0" step="1" value="100"></label>
                            <label><input type="radio" name="category_${fileObj.name}" value="juror" ${jurorChecked}> juror</label>
                            <label><input type="radio" name="category_${fileObj.name}" value="case" ${caseChecked}> case</label>
                            <button type="button" style="color: white" onclick="deleteFileRow('${fileObj.name}')">Delete</button>
                        </div>
                    </div>
                </td>
            `;
            
            // Insert before uploadRow (so files appear above the upload row)
            table.insertBefore(row, uploadRow);
            console.log('File row added successfully');
        }

        function deleteFileRow(filename) {
            uploadedFiles = uploadedFiles.filter(f => f.name !== filename);
            const table = document.getElementById('mainTable').getElementsByTagName('tbody')[0];
            const rows = table.querySelectorAll('tr[data-filename]');
            rows.forEach(row => {
                if (row.getAttribute('data-filename') === filename) {
                    table.removeChild(row);
                }
            });
            if (uploadedFiles.length === 0) addNoFilesRow();
            updateRowVisibility();
        }

        function removeNoFilesRow() {
            const row = document.getElementById('noFilesRow');
            if (row) {
                row.parentNode.removeChild(row);
            }
        }

        function addNoFilesRow() {
            if (document.getElementById('noFilesRow')) return;
            const table = document.getElementById('mainTable').getElementsByTagName('tbody')[0];
            const uploadRow = document.getElementById('uploadRow');
            const row = document.createElement('tr');
            row.id = 'noFilesRow';
            row.innerHTML = '<td style="color: #888;">No files yet.</td>';
            table.insertBefore(row, uploadRow);
        }

        async function uploadFilesToServer() {
            if (uploadedFiles.length === 0) {
                console.log('No files to upload');
                return false;
            }

            try {
                console.log('Clearing existing files and uploading...');
                
                // Create FormData to send actual files
                const formData = new FormData();
                
                // Collect all file metadata (including generated files)
                const allFileMetadata = [];
                
                // Add files and their metadata
                uploadedFiles.forEach(fileObj => {
                    const radioButtons = document.querySelectorAll(`input[name="category_${fileObj.name}"]:checked`);
                    const category = radioButtons.length > 0 ? radioButtons[0].value : 'juror';
                    
                    const weightInput = document.getElementById(`weight_${fileObj.name}`);
                    const weight = weightInput ? parseInt(weightInput.value) || 100 : 100;
                    
                    // Add to metadata list
                    allFileMetadata.push({
                        name: fileObj.name,
                        category: category,
                        weight: weight,
                        generated: fileObj.generated || false
                    });
                    
                    // Only add actual file objects (not generated files)
                    if (fileObj.file && !fileObj.generated) {
                        formData.append('files', fileObj.file);
                        formData.append('categories', category);
                        formData.append('weights', weight.toString());
                    }
                });

                // Add metadata for all files (including generated ones)
                formData.append('allFilesMetadata', JSON.stringify(allFileMetadata));

                // Always send the request (even if no new files) to update metadata
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    console.log('Files uploaded successfully:', result);
                    return true;
                } else {
                    console.error('Upload error:', result.error);
                    return false;
                }
            } catch (error) {
                console.error('Upload error:', error);
                return false;
            }
        }

        async function runProcess() {
            // First upload files
            const uploadSuccess = await uploadFilesToServer();
            if (!uploadSuccess) return;

            // Get form values
            const repeatCount = document.getElementById('repeatCount').value;
            const repeatModeRadio = document.querySelector('input[name="repeatMode"]:checked');
            const repeatMode = repeatModeRadio ? repeatModeRadio.value : 'individual';
            
            const evaluationOptions = [];
            if (document.getElementById('cb_participation').checked) evaluationOptions.push('participation');
            if (document.getElementById('cb_quality').checked) evaluationOptions.push('quality');
            if (document.getElementById('cb_arguments').checked) evaluationOptions.push('arguments');

            try {
                console.log('Starting notebook execution...');
                
                // Create output area for streaming results
                let outputArea = document.getElementById('outputArea');
                if (!outputArea) {
                    outputArea = document.createElement('div');
                    outputArea.id = 'outputArea';
                    outputArea.style.cssText = `
                        margin-top: 1em;
                        padding: 1em;
                        border: 1px solid #ccc;
                        max-height: 400px;
                        overflow-y: auto;
                        white-space: pre-wrap;
                        font-family: monospace;
                        font-size: 12px;
                    `;
                    // Append to the table body
                    const table = document.getElementById('mainTable').getElementsByTagName('tbody')[0];
                    const outputRow = document.createElement('tr');
                    const outputCell = document.createElement('td');
                    outputCell.appendChild(outputArea);
                    outputRow.appendChild(outputCell);
                    table.appendChild(outputRow);
                    
                    // Show the copy button when output area is created
                    const copyButton = document.getElementById('copyOutputButton');
                    if (copyButton) {
                        copyButton.style.display = 'inline-block';
                    }
                }
                outputArea.innerHTML = '';
                
                // Use Server-Sent Events to stream notebook execution
                const eventSource = new EventSource('/run_notebook?' + new URLSearchParams({
                    repeat_count: parseInt(repeatCount),
                    repeat_mode: repeatMode,
                    evaluation_options: JSON.stringify(evaluationOptions)
                }));
                
                eventSource.onmessage = function(event) {
                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.status === 'started') {
                            outputArea.innerHTML += `[STARTED] ${data.message}\n`;
                        } else if (data.status === 'output') {
                            outputArea.innerHTML += data.message + '\n';
                            outputArea.scrollTop = outputArea.scrollHeight;
                        } else if (data.status === 'completed') {
                            outputArea.innerHTML += `[COMPLETED] ${data.message}\n`;
                            eventSource.close();
                        } else if (data.status === 'error') {
                            outputArea.innerHTML += `[ERROR] ${data.message}\n`;
                            eventSource.close();
                        }
                    } catch (e) {
                        console.error('Error parsing SSE data:', e);
                        outputArea.innerHTML += `[ERROR] Failed to parse server response\n`;
                    }
                };
                
                eventSource.onerror = function(event) {
                    console.error('SSE error:', event);
                    outputArea.innerHTML += `[ERROR] Connection error occurred\n`;
                    eventSource.close();
                };
                
            } catch (error) {
                console.error('Run error:', error);
            }
        }

        function highlightGeneratedFileRow() {
            if (!lastGeneratedFilename) {
                return;
            }
            
            // Find the row with the generated filename
            const rows = document.querySelectorAll('#mainTable tbody tr[data-filename]');
            const targetRow = Array.from(rows).find(row => 
                row.getAttribute('data-filename') === lastGeneratedFilename
            );
            
            if (targetRow) {
                // Add highlight class - CSS animation will handle the fade
                targetRow.classList.add('file-row-highlight');
                
                // Remove class after animation completes (3s animation + small buffer)
                setTimeout(() => {
                    targetRow.classList.remove('file-row-highlight');
                }, 3100);
            }
            
            // Clear the stored filename after highlighting
            lastGeneratedFilename = null;
        }
    </script>
</body>
</html>